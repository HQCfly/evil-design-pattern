# evil-design-pattern

## Iterator模式
面向Iterator接口编程，无论底层的数据结构和迭代算法如何变化，调用者都不用修改代码
高内聚，低耦合，漂亮

如果自己写iterator模式，一般是研发底层的框架，比如提供某个数据给外部遍历，那么可以使用iterator模式自己封装迭代器，以后阶段如果有机会，我们也会去实践

## Adapter模式
场景介绍：

（1）假设我们做了一个第一版的一个系统，这个系统里有一个接口和一个实现类

（2）接着我们开始做第二版的系统，这个系统我们定义了一个新的接口，和新的实现类

（3）但是我们同时在第二版的系统中，也要使用第一版系统中定义的那个老接口和老实现类

## TemplateMethod模式
场景：

（1）我们有多种优惠策略

（2）不同的优惠策略在计算的价格的时候，有一些通用的基础逻辑

（3）每种优惠策略还有一些是自己特殊的价格计算的逻辑
这个模式一定要多用用，尤其是对于有多种不同实现的一些场景，比如说，不同的折扣类型，不同的优惠券类型，不同的商品类型，那肯定涉及到不同的处理逻辑。但是可以将他们共同的基础逻辑抽取到父类中，然后将要子类实现的逻辑留空，交给子类去实现。

## Factory模式
### 简单工厂模式
工厂模式的核心思想，其实就是不要自己在代码里手动new一个实现类对象出来，因为那样的话，调用方就不是面向接口编程了，你还得自己去care实现了。

我们设想一下，假设有N个client都new了一个ProductImpl出来，结果，到了后面某一天，你要把ProductImpl换成ProductNewImpl了，完全换一套实现逻辑，这个时候就完蛋了。你需要在N个client里，都修改new ProductImpl()这个方法，简直是一场灾难啊。尤其如果调用你的类的是别人呢？别人还得来care这个事情？

所以一般都是用工厂的思想来提供所有实现类实例，然后调用方面向接口来编程即可，接口不变，调用方代码不用变

### FactoryMethod模式：模板方法模式+简单工厂模式，简单工厂模式稍微复杂一点的变种

场景：

（1）我们现在要生产的产品有多种

（2）每种产品的生产过程，都有一些是共同的逻辑，但是也有一些是特殊的逻辑

（3）现在要生产出来各种产品
一般就是在有复杂工厂生产场景的情况下，比如就是需要多种工厂生产不同的产品，但是产品都是类似的，同时不同的工厂有一定的相同逻辑，那么就用这种模式

### AbstractFactory模式 -> 简单工厂模式的变种 -> 最复杂的一个变种

场景：

（1）就是我们现在要生产的不是一个一个产品，而一个一个的产品组合

（2）比如说我们有产品ABC，现在第一种产品组合是A+B，第二种产品组合是B+C，第三种产品组合是A+Cs

（3）就是要对工厂模式进行进一步的增强

## Singleton模式

单例模式，在系统里，你要判断一下，如果有一些类，只需要一个实例对象就可以了，那就给那个类做成单例的模式

## Facade模式
场景

1、假设我们现在有两个子系统

2、子系统A，有多个内部模块，模块A、模块B和模块C

3、子系统B，现在有一个功能，需要同时依赖3个模块来实现一个功能

外观模式其实很简单，就是说，假设我们有一个系统A吧，自己内部有多个代码组件，每个代码组件都可以实现一些功能。此时如果别的系统B要调用系统A实现某个功能，此时一种方法是，系统B调用系统A的多个代码组件的方法，最终实现一个功能。另外一个选择，就是系统A里提供一个Facade类，系统B不需要care系统A内部有多少个代码组件，直接调用系统A的一个facade类的一个方法即可。

就是说，大家可以想象一下，比如说service就是一个经典的门面模式

## Builder模式

场景

（1）构造一个复杂的对象，很多的属性，有些属性构造的时候需要做一些校验，格式转换

构造器是一种非常棒，非常实用，非常常用的设计模式，大家务必要掌握好

常见于在构建一个复杂的对象，或者是构建一个复杂的表达式的时候，在开源框架中有大量广泛的运用

给大家举个例子，Mockito框架中，when().thenReturn()之类的，其实就是构造器模式的一种，通过多个连续的方法完成一个模拟对象的构建；还有就是spring test框架汇总，MvcMock对象，也是通过thenExpected()等多个连续的方法，完成一个mvc测试对象的构建，这块我们首先在后面spring boot源码剖析的时候，会带着大家来阅读这些源码，掌握实践。同时在阶段一的电商系统设计中，我们对于一些复杂对象的构建，给大家举个例子，比如说销售出库单的构建，如此复杂的对象，采用构造器模式是非常合适的

用构造器模式的最大好处是啥？复杂对象的构建过程太复杂了，里面可能包含一些业务逻辑，比如值检查，格式转换之类的。如果每个客户端都自己手动去完成构建的话，那么大量的冗余代码是一个；另外一个，如果我们要改变对象的构建过程的实现，可以就在构造器中一个地方修改即可，对于调用方完全透明；最后，如果我们要完全替换掉以前的builder实现的话，那么完全可以在工厂里替换一个实现，还跟简单工厂模式结合起来使用了

## Prototype模式

场景，如果一个对象，我们希望拷贝一个这个对象，就是弄出来这个类的另外一个实例，实例的属性跟之前的实例是一模一样的

我们要用原型模式，以某一个对象为原型，然后对这个对象进行拷贝，得到拷贝后的另外一个对象
```java
public interface Prototype {
    
    Prototype clone();
    
}
public class ConcretePrototype implements Prototype {
    
    private String field1;
    private String field2;
    
    public Prototype clone() {
        Prototype prototype = new ConcretePrototype();
        prototype.setField1(field1);
        prototype.setField2(field2);
        return prototype;
    }
    
}

```

原型模式，顾名思义，其实说白了，就是让一个对象可以自己拷贝自己，对象把自己当成一个原型，然后提供一个方法出去，外部要一个对象的克隆和拷贝，直接就copy一份就可以了，但是这里要记住深拷贝和浅拷贝的区别

因为一个对象可能还持有别的对象的引用，浅拷贝就是不管引用的其他对象了；深拷贝就是将引用的对象也一起拷贝一份；一般原型模式都是要支持深拷贝的

而且其实一般实现原型模式的时候，直接是通过覆盖Object类的clone()方法即可，在里面实现自己的拷贝逻辑就可以了

使用原型模式比较好的一点，就是如果别人要拷贝你的对象，不需要调用方自己实现拷贝逻辑，将拷贝逻辑放在对象自己身体里就可以了，对外面调用都是透明的

## Mediator模式

场景
（1）三个模块

（2）模块1调用模块2和模块3；模块2要调用模块1和模块3；模块3要调用模块1和模块2

这个模式，担心的就是系统中各个子系统之前互相之间调用，乱成一团。所以就将系统之间互相调用的逻辑给放到一个所谓的中介者里面去。每个系统如果要通知别的系统干个什么事儿，直接就是调用中介者，中介者负责去调用别的系统。

我们来思考一下这个本质，其实说白了，这个模式就是要让各个系统之间彻底解耦，不要互相强耦合在一起，互相调用过多，调用关系过于混乱。互相调用的时候通过一个中间的组件来解耦。

在实际的企业开发中，不是这么玩儿的，很少有见到说封装一个所谓的中介者，去让各个模块之间解耦，思考这个模式的本质，让各个模块之间解耦合

最最常见的一个方式，就是系统与系统之间，不是走直接的接口调用，而是基于MQ来解耦。录入过模块A要调用模块B和模块C，模块A发送一条消息到MQ里面去，模块B和模块C去消费这条消息，读到消息之后，知道模块A要调用自己，所以就执行对应的逻辑即可。常见于系统与系统之间的调用，可以基于MQ消息，异步执行的方式来调用，不需要同步调用和执行。

大家想一下，这不就是典型的各个子系统用MQ来解耦么，有些操作，互相直接不是直接调用，消息发送到MQ，通过MQ来解耦。我们在电商系统里也完全有这种场景，到后面我们设计系统的时候给大家分析。我们可以封装一个基于内存队列的异步解耦中介者组件，然后让系统间有些可以异步的操作通过中介者来执行，降低互相调用的复杂度。

模块A将消息发送到一个内存队列中去，其他的模块去内存队列中消费自己感兴趣的消息，来执行对应的操作，用队列替代了中介者，让各个模块之间解耦合，rabbitmq去做

## Proxy模式
代理模式实在是太常见太常见了，2个场景：

（1）懒加载：hibernate、mybatis，都可以实现懒加载，这个大家应该都知道了，其实也是基于动态代理思想实现的，对刚查询出来的对象做一个代理。然后去调用getX()方法的时候，再实际执行sql查询出来关联的数据。

## Observer模式
场景

（1）比如我们有一个目标对象，一旦这个目标对象的状态改变了，然后的话就去通知相关的对象，我的状态改变了，数据也变化了


观察者模式还是非常常用的，不过说实话，常见于基于zookeeper进行分布式系统之间的协调工作，比如分布式锁的注册以及监听是否释放。还有就是两个系统之间如果做了异步的处理，那么如果A系统发送异步请求给了B系统，但是要得到B系统的一个状态改变的消息，可以采用观察者模式。
基于zookeeper去做分布式锁

（1）系统A尝试获取zookeeper上的一个锁，获取到了

（2）系统B尝试获取zookeeper上的一个锁，被系统A给锁了，没有获取到锁，此时系统B在zookeeper上可以注册一个监听器（观察者）

（3）系统A一旦将锁给释放了，zookeeper感受到锁被释放了，就会立即通知系统B注册的那个监听器

（4）系统B就立即被通知到了，系统A释放了锁，系统B可以重新尝试在zookeeper上加锁

## Command模式
命令模式是很常用的，一般就是说，你可能会执行一些操作，这些操作都实现一个接口，但是有不同的命令实现，然后命令的执行类就是同一个，你需要执行哪个命令就封装那个命令后发送给执行类即可

## Composite模式
场景：

（1）父部门->子部门->子部门

（2）我们要对部门树，删除一个父部门以及其下所有的子部门

组合模式非常适用于有较多父子层级关系的那种场景，比如部门树的递归删除，或者是文件树的递归删除之类的场景。这个还是比较好模拟的，我们会在电商系统的权限那块给大家演示，比如删除一个父权限，就要级联递归删除所有的子权限，这个时候可以对组合模式做一点变种，自动从根权限开始，递归查询所有层级的子权限，然后一直到叶子节点的权限，从叶子节点开始删除

## Strategy模式

场景

（1）我们可以根据不同的参数来选择一种我们想要执行的优惠计价方式

策略模式，将会成为最最高频使用的一种设计模式，他的常见应用场景，就是替换掉那一大坨复杂难懂的if else if else。对于那种过于复杂的选择判断逻辑，完全可以将选择哪种策略的过程放到工厂里去。工厂，可以是简单工厂，也可以是工厂方法，也可以是抽象工厂。

## State模式
场景

（1）销售出库单，状态需要从新建、待审批、已审批、已完成，四个状态之间流转，流转到每个状态的时候，都需要执行那个状态对应的一个逻辑

其实状态模式，就是维护多种不同的状态，每种状态下可以去执行一些特殊的逻辑。然后由一个Context类负责根据请求参数调用，来维护这些状态之间的切换，形成一个状态机的概念。

状态模式里，非常重要的一点就是将状态之间流转的逻辑，封装在Context类里面。本来可能需要调用方自己维护复杂的状态流转逻辑，流转到不同的状态之后，执行状态对应的代码逻辑。

这个状态模式，在电商系统中有天然的运用场景，我们的系统中很多数据都有大量的状态变更的逻辑，我们可以将状态变更的逻辑用状态模式来实现，将状态流转封装在一个地方，每次状态变更就通知那个组件，让状态流转，同时执行状态对应的代码逻辑

## Memento模式

场景

（1）类，计算出来一份中间数据

（2）这个类，之后需要基于这份中间数据再执行另外两次操作，每次操作都要基于这份中间数据去执行

（3）第一次基于中间数据操作过后，会对中间数据做出修改

（4）要求是第二次再执行操作的时候，需要基于未修改之前的中间数据来执行

## Flyweight模式
场景

（1）我们现在要缓存一些数据，比如说权限，根据权限的ID作为key，权限数据自己本身是value

（2）但是我们不需要使用太复杂的ehcache框架之类的去使用，特别特别的简单的

（3）我们就想基于自己的Map去实现一套东西

享元模式，从最基本的角度来说，其实就是维护固定数量的对象实例，不同的对象实例，只有一个，然后保存在内部的一个map中。可以算是跟单例模式的一个扩展和结合吧。

## Decorator模式

场景
（1）假设我们手头已经有了一个类，可以执行一些功能

（2）但是我们还是希望对这个类的功能做一些增强，此时怎么办呢？基于已有的类的功能基础之上，再增强一些功能，可以做装饰

## ChainOfResponsibility模式

场景：

（1）现在在某一个地方的业务流程，要执行功能1、功能2、功能3

（2）现在在另外一个地方的业务流程，是要先执行功能3，然后执行功能1和功能2

责任链模式，那也是经常会使用到的，对于那种复杂的业务流程，一种方案是采取面向对象的设计，将不同的业务逻辑封装到不同的类里去，然后通通过方法中的调用来控制业务流向；另外一种就是采用责任链模式，将业务逻辑封装到不同的handler里面去，形成链条式调用。

## Bridge模式

所谓的桥接，就是搭建一个桥，让两个组件之间互相调用，可以通过桥来执行。因为有了桥，两个代码组件无论怎么修改，都互相没有影响。这个桥，实际上就是一个接口。所以说，java中，无处不桥接，只要你是面向接口编程，基本就是在桥接。

## Visitor模式
场景

（1）组合模式，我们现在想象一下，我们之前做的是说递归删除部门自己本身

（2）但是我们现在要对他改造一下，将组合模式和访问者模式结合起来，就是说，我们可以让那颗树执行我们想要他做的任何事情

访问者模式，是对目标对象，动态的执行某个功能，而不对目标对象有任何的改动